---
title: 事务
icon: /logo/dbeaver-light.svg
createTime: 2024/09/25 16:30:24
permalink: /interview/znj7ig7o/
---
::: tip 提问
1. 是否有了解过分布式事务的一致性, 底层如何实现?
2. 数据库的事务是什么?
3. 脏读, 重复读是什么?
4. 数据库事务的隔离级别?
:::
## 分布式事务一致性
### 2 PC
**第一阶段**
协调者向所有参与者发送命令, 参与者锁定资源, 本地执行. 如果执行成功则向协调者发送 `ready`, 失败则发送 `fail`.

**第二阶段**
如果所有协调者都发送了 `ready` 则协调者向所有参与者发送 `commit`, 否则发送 `rollback` 全部参与者都进行回退.

### TCC
在 2 PC 的基础上先检查参与者的心跳, 保证参与者都能响应命令.

> 阿里提供 `Seata` 中间件可以保证分布式事务的一致性.

## 事务
事务(Transaction)指一个操作, 由多个步骤组成, 要么全部成功, 要么全部失败.

- 原子性
- 一致性
- 持久性
- 隔离性

## 脏读/不可重复读/幻读
1. 脏读.

   读取未提交的数据.
2. 不可重复读.

   前后多次读取的数据内容不一致.

3. 幻读.

   前后多次读取数据的总量不一致.

## 事务隔离级别
### 读未提交(Read Uncommited)
相当于没有做任何处理, 并发会导致的问题全部都会出现.

### 读已提交(Read Commited)
只能读其他事务已经提交的数据, 可解决**脏读**问题.

==是大多数数据库的隔离级别, 但是不包括 MySQL==.

### 可重复读(Repeatable Read)
在某事务的执行过程中不允许其他事务 `update`, 但是允许 `insert`.

==MySQL使用的级别==.

### 可串行化(Serializable)
所有的事务串行执行, 不存在并发冲突.

|          | 脏读               | 不可重复读         | 幻读               |
| -------- | ------------------ | ------------------ | ------------------ |
| 读未提交 | :x:                | :x:                | :x:                |
| 读已提交 | :heavy_check_mark: | :x:                | :x:                |
| 可重复读 | :heavy_check_mark: | :heavy_check_mark: | :x:                |
| 可串行化 | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |
