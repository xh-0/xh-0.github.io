---
title: Redis
icon: /logo/redis-light.svg
createTime: 2024/09/25 15:54:57
permalink: /interview/uqcg8do8/
---
::: tip 提问
1. Redis 有哪些常见的类型?
2. Redis 对于已过期的数据如何淘汰?
3. 如何保证与 MySQL 之间的一致性?
4. 为什么先操作数据库?
5. 应该更新缓存还是删除缓存?
:::

## 常见的数据类型
1. String
2. Set: 集合
3. Zset: 有序集合
4. List
5. Hash: dict

## Set 和 Zset 之间的区别:
Zset 是有序的, 额外提供了一个 double 类型的评分进行排序. 评分可以重复, 但是元素不能重复.

## Zset 和 List 之间的区别:
List 的元素可以重复, 实现上使用的是双向链表.

Zset 保证元素之间的唯一性, 实现上使用的是跳表.

## 淘汰机制
详情见[Redis 详解](/article/jbhd1al8/#淘汰机制)


## 缓存一致性
我们先来看为什么会导致缓存与数据库的不一致. 这种不一致通常是由于多线程并发读写引起的.

### 延迟双删
#### 读操作
缓存命中, 直接返回; 缓存没有命中则查询数据库, 写入缓存, 设定超时时间.

#### 写操作
::: steps
1. 先删除缓存.

2. 再更新数据库.

3. 休眠一会(比如1秒), 再次删除缓存.
:::

### 为什么先操作数据库?
必须先==更新数据库==.

我们来看如果先操作缓存会发生什么.

::: steps
1. 线程 A 发起一个写操作, 第一步 del cache.

2. 此时线程 B 发起一个读操作, cache miss.

3. 线程 B 继续读 DB, 读出来一个老数据.

4. 然后线程 B 把老数据设置入 cache.

5. 线程 A 写入最新的数据到 DB.
:::
此时数据库是新数据, Redis 是老数据, 不一致了.

### 到底是删除缓存呢, 还是更新缓存?
应当 ==删除缓存==.

我们看如果不删除缓存而是更新缓存会怎么样:
::: steps
1. 线程 A 先发起一个写操作, 第一步先更新数据库.

2. 线程 B 再发起一个写操作, 第二步更新了数据库.

3. 由于网络等原因, 线程 B 先更新了缓存.

4. 线程 A 更新缓存.
:::
此时数据库里面是 B 的数据, 而缓存里面是 A 的数据.
